import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { v4 as uuidv4 } from 'uuid';
import { Settings } from '../../../../helpers/settings';
import { ProductModel } from '../models/product-model';

@Injectable({
  providedIn: 'root',
})
export class ProductService {
  
  constructor(private http: HttpClient) {
    const CONFIG = Settings.getInstance();
  }

  public index(categoryid: string): Observable<any> {

    return this.http
      .get(Settings.CategoriesTable + '/' + categoryid + '/products' + Settings.ext)
      .pipe(map(this.convertObjectToArrayProducts));
  }

  public create(): string {

    const newId = uuidv4();
    return newId;
  }

  public createProductStock(arrayProduct: ProductModel[], categoryId: string): Observable<any> {

    arrayProduct.forEach(
      (product: ProductModel) => {
        if(product.selected){
          const productStock: ProductModel = { ...product };
          delete productStock.id;

          this.http.put(Settings.CategoriesTable + '/' + categoryId + '/products/' + product.id + Settings.ext, productStock).subscribe();
        }
    });

    const categoryKardex: object = { "kardex": true};

    return this.http.patch(Settings.CategoriesTable + '/' + categoryId + Settings.ext, categoryKardex);
  }

  public store(product: ProductModel): Observable<any> {

    const producTemp: ProductModel = { ...product };
    delete producTemp.id;
    delete producTemp.categoryid;
    producTemp.stock = 1;
    producTemp.quantity = 0;
    producTemp.selected = false;

    return this.http.patch(Settings.CategoriesTable + '/' + product.categoryid + '/products/' + product.id + Settings.ext, producTemp);
  }
  
  public update(product: ProductModel): Observable<any> {

    const modelTemp = { ...product };
    delete modelTemp.id;
    delete modelTemp.categoryid;

    return this.http.put(
      Settings.CategoriesTable + '/' + product.categoryid + '/products/' + product.id + Settings.ext,
      modelTemp
    );
  }

  public destroy(categoryId: string, productId:string): Observable<any> {

    return this.http.delete(Settings.CategoriesTable + '/' + categoryId + '/products/' + productId + Settings.ext);
  }

  private convertObjectToArrayProducts(obj: object): ProductModel[] {

    if (obj === null) {
      return [];
    }

    const arrayProducts: ProductModel[] = [];

    Object.keys(obj).forEach((key) => {
      const modelProduct: ProductModel = obj[key];
      modelProduct.id = key;
      arrayProducts.push(modelProduct);
    });

    const arraySelected: ProductModel[] = arrayProducts.filter((p) => !p.selected);

    arraySelected.sort((a, b) => {
      let fa = a.name.toLowerCase(),
        fb = b.name.toLowerCase();
      if (fa < fb) return -1;
      if (fa > fb) return 1;
      return 0;
    });

    return arraySelected;
  }
}
